program 1:
#include<stdio.h>
#include<stdlib.h>
struct day{
    char *dayname;
    int date,month,year;
    char *activitydescription;
};
struct day *createcalender(int size){
    struct day *calender=(struct day*)malloc(size*sizeof(struct day));
    if(calender==NULL){
        printf("memory allocation failed");
        exit (0);
    }
    return calender;
}
void readdata(struct day *calender, int size){
    for(int i=0;i<size;i++){
        printf("enter the detailes of the %d day",i+1);
        printf("dayname:");
        calender[i].dayname=(char*)malloc(20*sizeof(char));
        scanf("%s",calender[i].dayname);
        printf("date:\n");
        scanf("%d",&calender[i].date);
        printf("month:\n");
        scanf("%d",&calender[i].month);
        printf("year:\n");
        scanf("%d",&calender[i].year);
        printf("activity description:\n");
        calender[i].activitydescription=(char*)malloc(50*sizeof(char));
        scanf("%s",calender[i].activitydescription);
    }
}
void display(struct day *calender,int size){
    printf("dayname\tdate\tactivitydescription\n");
    for(int i=0;i<size;i++){
        printf("%s\t\t%d-%d-%d\t\t%s\n",calender[i].dayname,calender[i].date,calender[i].month,calender[i].year,calender[i].activitydescription);
    }
}
void freememory(struct day *calender,int size){
    for(int i=0;i<size;i++){
        free(calender[i].dayname);
        free(calender[i].activitydescription);
    }
    free(calender);
}
int main(){
    int size;
    printf("enter the number of days\n");
    scanf("%d",&size);
    struct day *calender=createcalender(size);
    readdata(calender,size);
    display(calender,size);
    freememory(calender,size);
}


2.String Matching 
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
void stringmatch(char str[100],char pat[50],char rep[50])
{
int i=0,m=0,c=0,j=0,k=0,flag=0;
char ans[50];
while(str[c]!='\0')
{
if(str[m]==pat[i])
{
i++;
m++;
if(pat[i]=='\0')
{
flag=1;
for(k=0;rep[k]!='\0';k++,j++)
ans[j]=rep[k];
i=0;
c=m;
}
}
else
{
ans[j]=str[c];
j++;
c++;
m=c;i=0;
}
}
ans[j]='\0';
if(flag==1)
printf("\n The resultant string is \n %s",ans);
else
printf("\n Pattern string NOT found \n");
}
void readstring(char str[],char pat[],char rep[])
{
printf("\n Enter a main string \n");
gets(str);
printf("\n Enter a pattern string \n");
gets(pat);
printf("\n Enter a replace string \n");
gets(rep);
}
void main()
{
char str[100],pat[50],rep[50];
readstring(str,pat,rep);
stringmatch(str,pat,rep);
}


program 03 
#include<stdio.h>
#include<stdlib.h>
#define max 4
void push(int s[],int *top){
    int ele;
    if(*top==max-1){
        printf("stach overflow");
    }
    else{
        printf("enter the item to be inserted in the stack");
        scanf("%d",&ele);
        s[++(*top)]=ele;
    }
}
int pop(int s[],int *top){
    return (s[(*top)--]);
}
void palindrom(int v[],int top){
    int i=0,flag=0,ele;
    for(i=0;i<(top+1);i++){
    ele=pop(v,&top);
    if(ele==v[i])
    flag=1;
    else
    flag=0;
}
if(flag==0)
    printf("stack elements are not palindrom");
    else
    printf("stack elements are palindrom");
}
void display(int s[],int top){
    int i;
    if(top==-1)
        printf("stack underflow\n");
        else{
            printf("the stack elements are:\n");
            for(int i=0;i<=top;i++)
            printf("%d",s[i]);
        }
    }
    int main(){
        int ch,ele,s[max],top=-1;
        while(1){
        printf("menu option\n1.push into stack\n2.pop from the top\n3.palindrom\n4.display\n5.exit\n");
        printf("enter your choice\n");
        scanf("%d",&ch);
        switch(ch){
            case 1:push(s,&top);
            break;
            case 2:if(top==-1){
                printf("stack underflow\n");
            }
            else{
                ele=pop(s,&top);
                printf("the deleted element is %d",ele);
            }
            break;
            case 3:palindrom(s,top);
            break;
            case 4:display(s,top);
            break;
            case 5:exit(1);
            break;
            default:printf("enter the valid choice\n");
            break;
            
            }
            }
        }



        program 04:
        #include<stdio.h>
#include<string.h>
int f(char);
int g(char);
void infixtopostfix(char[],char[]);
int f(char sym){
    switch(sym){
        case '+':
        case '-':return 2;
        case '*':
        case '/':
        case '%':return 4;
        case '^':
        case '$':return 5;
        case '(':return 0;
        case '#':return -1;
        default: return 8;
    }
}
int g(char sym){
    switch(sym){
        case '+':
        case '-':return 1;
        case '*':
        case '/':
        case '%':return 3;
        case '^':
        case '$':return 6;
        case '(':return 9;
        case ')':return 0;
        default: return 7;
    }
}
int main(){
    char infix[50],postfix[50];
    printf("enter the infix expression\n");
    scanf("%s",infix);
    infixtopostfix(infix,postfix);
    printf("infix expression is %s and the equvalent postfix expression is %s",infix,postfix);
    return 0;
}
void infixtopostfix(char in[],char post[]){
    int i=0,j=0,top=-1;
    char stk[50],sym;
    stk[++top]='#';
    while(in[i]!='\0'){
        sym=in[i++];
        while(f(stk[top])>g(sym))
            post[j++]=stk[top--];
            if(f(stk[top])!=g(sym))
            stk[++top]=sym;
            else
            stk[top--];
        }
    
    while(stk[top]!='#'){
        post[j++]=stk[top--];
    }
    post[j++]='\0';
}


5.Evaluation of suffix Expression */
#include<stdio.h>
#include<stdlib.h>
#include<math.h>
void tower(int n,int source,int temp,int destination)
{
 if(n==0)
 return;
 tower(n-1,source,destination,temp);
 printf("\n move disc %d from %c to %c",n,source,destination);
 tower(n-1,temp,source,destination);
}
void push(float stk[],int *top,float op)
{
 *top=*top+1;
 stk[*top]=op;
}
int pop(float stk[],int *top)
{
 float res;
if(*top==-1)
 {
 printf("stack is underflow");
 return;
 }
 else
 {
 res=stk[*top];
 *top=*top-1;
 return res;
 }
}
float compute(float op1,float op2,char s)
{
switch(s)
{
case '+' : return (op1+op2);
case '-' : return (op1-op2);
case '*' : return (op1*op2);
case '/' : return (op1/op2);
case '$' :
case '^' : return pow(op2,op1);
}
}
void evalpostfix()
{
char sym,post[20];
 int i=0,j=0,top=-1;
 float stk[20],item,op1,op2,res;
 printf("enter the valid postfix expn:");
 scanf("%s",post);
 while(post[i]!='\0')
 {
 sym=post[i++];
 if(isdigit(sym))
 {
 item=sym-'0';
 push(stk,&top,item);
 }
 else
 {
 op2=pop(stk,&top);
 op1=pop(stk,&top);
 res=compute(op1,op2,sym);
 push(stk,&top,res);
 }
 }
 res=pop(stk,&top);
printf("the result of evaluation of postfix expn is %f",res);
}
void main()
{
 int n,ch;
 printf("\n main menu");
while(1)
 {
 printf("\n 1.evalution of postfix expn");
 printf("\n 2.tower of honoi");
 printf("\n 3.exit");
 printf("\nenter your choice:");
 scanf("%d",&ch);
 switch(ch)
 {
 case 2: printf("\n enter the no. of discs :");
 scanf("%d",&n);
 tower(n,'A','B','C');
 printf("\n total no. of moves are"); 
 break;
 case 1: evalpostfix();
break;
 case 3: exit(0);
 }
}
}

program 06:
#include<stdio.h>
#include<stdlib.h>
#define max 2
void insert(char q[],int *r,int *count){
    int ele;
    if(*count==max){
        printf("queue overflow\n");
        return;
    }
    else{
     *r=(*r+1)%max;
    printf("enter the element to be inserted\n");
    scanf("%s",&ele);
    q[*r]=ele;
    (*count)++;
    }
}
void deleteele(char q[],int *f,int *count){
    if(*count==0){
        printf("queue underflow\n");
        return;
    }
    else{
        printf("deleted element is %s",q[*f]);
        *f=(*f+1)%max;
      ( *count)--;
    }
}
void display(char q[],int f,int count){
    int j,i;
    if(count==0){
        printf("queue underflow\n");
        return;
    }
    else{
        j=f;
        for(i=0;i<count;i++){
            printf("%d",q[j]);
            j=(j+1)%max;
        }
    }
}
void main(){
    int ch;
    char q[max];
    int f=0,r=-1,count=0;
    while(1){
        printf("menu option\n1.insert into the queue\n2.delete from the queue\n3.display\n 4.exit\n");
        printf("enter your choice\n");
        scanf("%d",&ch);
        switch(ch){
            case 1:insert(q,&r,&count);
            break;
            case 2:deleteele(q,&f,&count);
            break;
            case 3:display(q,f,count);
            break;
            case 4:exit(0);
            break;
            default:printf("enter the valid choice\n");
            break;
        }
    }
} 





stack
#include<stdio.h>
#include<stdlib.h>
#define maxsize 4
int push(int s[],int *top) 
{
int ele;
if(*top==(maxsize-1))
{
printf("\n\nstack is overflow");
return;
}
else
{
printf("\n enter a element to be pushed :");
scanf("%d",&ele);
s[++(*top)]=ele;
}
}
int pop(int s[],int *top)
{
int ele;
ele=s[(*top)--];
return ele;
}
void palindrome(int v[],int top)
{
int flag=0,i;
for(i=0;i<(top+1);i++)
{
if(v[i]==pop(v,&top))
flag=1;
else
{
flag=0;
break;
}
}
if(flag)
printf("stack contents are palindrome");
else
printf("stack contents are not palindrome");
}
void display(int s[],int top)
{
int i;
if(top==-1)
{
printf("\n stack is empty");
return;
}
else
{
printf("\n the stack contents are");
for(i=top;i>=0;i--)
{
printf("\n[%d]",s[i]);
printf("\n");
}
}
}
void main()
{
int s[maxsize],ele;
int ch,top=-1;
while(1)
{
printf("\n----------->MAIN MENU<----------\n");
printf("\n1---------->PUSH into the stack<------");
printf("\n2---------->POP from the stack<------");
printf("\n3---------->PALINDROME check using stack<----");
printf("\n4----------> DISPLAY<-----------");
printf("\n5---------->EXIT<------");
printf("\n enter your choice:");
scanf("%d",&ch);
switch(ch)
{
case 1:push(s,&top);
 display(s,top);
 break;
case 2:if(top==-1)
{
 printf("\n stack under flow");
}
else
{
 ele=pop(s,&top);
 printf("\n popped element is %d",ele);
 }
break;
case 3:palindrome (s,top);
 break;
case 4:display(s,top);
 break;
case 5:exit(0);
 break;
 default:printf("\n enter a valid choice");
break;
}
}
}



4.Conversion of infix to postfix expression 
#include<stdio.h>
#include<string.h>
int f(char);
int g(char);
void infixtopostfix(char in[],char post[])
{
int i=0,j=0,top=-1;
char stk[20],sym;
stk[++ top]='#';
while(in[i]!='\0')
{
sym=in[i++];
while(f(stk[top])>g(sym))
post[j++]=stk[top--];
if(f(stk[top])!=g(sym))
stk[++top]=sym;
else
stk[top--];
}
while(stk[top]!='#')
{
post[j++]=stk[top--];
}
post[j++]='\0';
}
int f(char sym)
{
switch(sym)
{
case '+':
case '-':return 2;
case '%':
case '*':
case '/':return 4;
case '$':
case '^':return 5;
case '(':return 0;
case '#':return-1;
default:return 8;
}
}
int g(char sym)
{
switch(sym)
{
case '+':
case '-':return 1;
case '%':
case '*':
case '/':return 3;
case '$':
case '^':return 6;
case '(':return 9;
case ')':return 0;
default:return 7;
}
}
int main()
{
char infix[50],postfix[50];
printf("enter the valid infix expression \n");
scanf("%s",infix);
infixtopostfix(infix,postfix);
printf("the given infix expression is %s and the equivalent postfix espression is 
%s",infix,postfix);
return 0;
}




 5.Evaluation of suffix Expression */
#include<stdio.h>
#include<stdlib.h>
#include<math.h>
void tower(int n,int source,int temp,int destination)
{
 if(n==0)
 return;
 tower(n-1,source,destination,temp);
 printf("\n move disc %d from %c to %c",n,source,destination);
 tower(n-1,temp,source,destination);
}
void push(float stk[],int *top,float op)
{
 *top=*top+1;
 stk[*top]=op;
}
int pop(float stk[],int *top)
{
 float res;
if(*top==-1)
 {
 printf("stack is underflow");
 return;
 }
 else
 {
 res=stk[*top];
 *top=*top-1;
 return res;
 }
}
float compute(float op1,float op2,char s)
{
switch(s)
{
case '+' : return (op1+op2);
case '-' : return (op1-op2);
case '*' : return (op1*op2);
case '/' : return (op1/op2);
case '$' :
case '^' : return pow(op2,op1);
}
}
void evalpostfix()
{
char sym,post[20];
 int i=0,j=0,top=-1;
 float stk[20],item,op1,op2,res;
 printf("enter the valid postfix expn:");
 scanf("%s",post);
 while(post[i]!='\0')
 {
 sym=post[i++];
 if(isdigit(sym))
 {
 item=sym-'0';
 push(stk,&top,item);
 }
 else
 {
 op2=pop(stk,&top);
 op1=pop(stk,&top);
 res=compute(op1,op2,sym);
 push(stk,&top,res);
 }
 }
 res=pop(stk,&top);
printf("the result of evaluation of postfix expn is %f",res);
}
void main()
{
 int n,ch;
 printf("\n main menu");
while(1)
 {
 printf("\n 1.evalution of postfix expn");
 printf("\n 2.tower of honoi");
 printf("\n 3.exit");
 printf("\nenter your choice:");
 scanf("%d",&ch);
 switch(ch)
 {
 case 2: printf("\n enter the no. of discs :");
 scanf("%d",&n);
 tower(n,'A','B','C');
 printf("\n total no. of moves are"); 
 break;
 case 1: evalpostfix();
break;
 case 3: exit(0);
 }
}
}





/*6.Circular Queue operations */
#include<stdio.h>
#include<stdlib.h>
#define MAXSIZE 4
void insert(char q[],int *r,int *c)
{
 char item;
 if(*c==MAXSIZE)
 {
 printf("\n queue is full");
 return;
 }
 else
 {
 printf("enter the character to be inserted:");
 scanf(" %c",&item);
 *r=(*r+1)% MAXSIZE;
 q[*r]=item;
 (*c)++;
 }
}
void deleteq(char q[],int *f,int *c)
{
 char item;
if(*c==0)
 {
 printf("\n queue is empty");
 return;
 }
 item=q[*f];
 printf("\n deleted item is :%c",item);
 *f=(*f+1)%MAXSIZE;
 (*c)--;
}
void display(char q[],int f,int *c)
{
 int i;
 if(*c==0)
 printf("\nqueue is empty");
 else
 {
 printf("\n contents of queue is \n");
 for(i=1;i<=*c;i++)
 {
 printf("%c \t",q[f]);
 f=(f+1)%MAXSIZE;
 }
 }
}
void main()
{
 int ch,f=0,r=-1,c=0;
 char q[MAXSIZE];
 while(1)
 {
 printf("\n main menu");
 printf("\n1.insert");
 printf("\n2.delete");
 printf("\n3.display");
 printf("\n4.exit");
 printf("\n enter choice:");
 scanf("%d",&ch);
 switch(ch)
 {
 case 1 :insert(q,&r,&c);
 break;
 case 2 : deleteq(q,&f,&c);
 break;
case 3 : display(q,f,&c);
 break;
 case 4 : exit(0);
 }
 }
}